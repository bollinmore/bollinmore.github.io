{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Leetcode log","title":"Home"},{"location":"#leetcode-log","text":"","title":"Leetcode log"},{"location":"about/","text":"Alvin Chen - SuperQ","title":"About"},{"location":"about/#alvin-chen-superq","text":"","title":"Alvin Chen - SuperQ"},{"location":"template/","text":"Source Topic : Constraints Concept Complexity Time Complexity Space Complexity Special test case Code","title":"Template"},{"location":"template/#_1","text":"Source Topic : Constraints","title":""},{"location":"template/#concept","text":"","title":"Concept"},{"location":"template/#complexity","text":"Time Complexity Space Complexity","title":"Complexity"},{"location":"template/#special-test-case","text":"","title":"Special test case"},{"location":"template/#code","text":"","title":"Code"},{"location":"array/find_pivot_index/","text":"Find Pivot Index Source Topic : Array, Prefix Sum Given an array of integers nums, calculate the pivot index of this array. The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right. If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array. Return the leftmost pivot index. If no such index exists, return -1. Constraints 1 <= nums.length <= 104 -1000 <= nums[i] <= 1000 Concept Since we know the sum of left part is equal to the right part, and the sum of all elements will not change, we could solve this problem by checking the left part and right part iteratively . How do we get the sum of right part? You'll get the sum by total - leftSum - pivot . Complexity Time Complexity O(n): O(n) for getting sum of all numbers; O(n) for checking the leftSum & rightSum. Space Complexity O(1) Special test case Code class Solution { public: int pivotIndex(vector<int>& nums) { int sz = nums.size(); int leftSum=0, total=0; total = std::accumulate(nums.begin(), nums.end(), 0); //O(n) for (int i=0; i<sz; i++) { int rightSum = total - nums[i] - leftSum; if (leftSum == rightSum) return i; leftSum += nums[i]; } return -1; // not found } };","title":"724. Find Pivot Index"},{"location":"array/find_pivot_index/#find-pivot-index","text":"Source Topic : Array, Prefix Sum Given an array of integers nums, calculate the pivot index of this array. The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right. If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array. Return the leftmost pivot index. If no such index exists, return -1. Constraints 1 <= nums.length <= 104 -1000 <= nums[i] <= 1000","title":"Find Pivot Index"},{"location":"array/find_pivot_index/#concept","text":"Since we know the sum of left part is equal to the right part, and the sum of all elements will not change, we could solve this problem by checking the left part and right part iteratively . How do we get the sum of right part? You'll get the sum by total - leftSum - pivot .","title":"Concept"},{"location":"array/find_pivot_index/#complexity","text":"Time Complexity O(n): O(n) for getting sum of all numbers; O(n) for checking the leftSum & rightSum. Space Complexity O(1)","title":"Complexity"},{"location":"array/find_pivot_index/#special-test-case","text":"","title":"Special test case"},{"location":"array/find_pivot_index/#code","text":"class Solution { public: int pivotIndex(vector<int>& nums) { int sz = nums.size(); int leftSum=0, total=0; total = std::accumulate(nums.begin(), nums.end(), 0); //O(n) for (int i=0; i<sz; i++) { int rightSum = total - nums[i] - leftSum; if (leftSum == rightSum) return i; leftSum += nums[i]; } return -1; // not found } };","title":"Code"},{"location":"array/gas_station/","text":"134. Gas Station Source There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique Constraints gas.length == n cost.length == n 1 <= n <= 105 0 <= gas[i], cost[i] <= 104 Concept: One pass algorithm The basic idea is: The total gas must larger than total cost, otherwise there is no way to travel around the circuit. If the tank is less zero , we move the starting point to the next station. Why one pass works is because we assuming the oil is sufficient so we can always reset the starting point if tank + gas - cost < 0 Complexity Time Complexity O(n^2): We have a nested for-loop inside because we need to move root node. Space Complexity O(n): Extra space to hold the number of unique BST of N. Code: class Solution { public: int canCompleteCircuit(vector<int>& gas, vector<int>& cost) { /** 2022/1/21 -- O(n), O(1); One pass */ int tank = 0; int start = 0, total_gas = 0, total_cost = 0; for (int i=0; i<gas.size(); i++) { total_gas += gas[i]; total_cost += cost[i]; tank += (gas[i] - cost[i]); if (tank < 0) { // start = i+1; tank = 0; } } return (total_gas >= total_cost) ? start : -1; } };","title":"134. Gas Station"},{"location":"array/gas_station/#134-gas-station","text":"Source There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique Constraints gas.length == n cost.length == n 1 <= n <= 105 0 <= gas[i], cost[i] <= 104","title":"134. Gas Station"},{"location":"array/gas_station/#concept","text":"One pass algorithm The basic idea is: The total gas must larger than total cost, otherwise there is no way to travel around the circuit. If the tank is less zero , we move the starting point to the next station. Why one pass works is because we assuming the oil is sufficient so we can always reset the starting point if tank + gas - cost < 0","title":"Concept:"},{"location":"array/gas_station/#complexity","text":"Time Complexity O(n^2): We have a nested for-loop inside because we need to move root node. Space Complexity O(n): Extra space to hold the number of unique BST of N.","title":"Complexity"},{"location":"array/gas_station/#code","text":"class Solution { public: int canCompleteCircuit(vector<int>& gas, vector<int>& cost) { /** 2022/1/21 -- O(n), O(1); One pass */ int tank = 0; int start = 0, total_gas = 0, total_cost = 0; for (int i=0; i<gas.size(); i++) { total_gas += gas[i]; total_cost += cost[i]; tank += (gas[i] - cost[i]); if (tank < 0) { // start = i+1; tank = 0; } } return (total_gas >= total_cost) ? start : -1; } };","title":"Code:"},{"location":"array/partition_array_into_three_parts_with_equal_sum/","text":"1013. Partition Array Into Three Parts With Equal Sum Source Topic : Array, Greedy Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums. Formally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]) Constraints 3 <= arr.length <= 5 * 104 -104 <= arr[i] <= 104 Concept The basic idea is to sum up a range of value and check if it is equal to total/3 , we'll Increase part variable if the condiction meet. Finally, return true if part>=3 , why? Because every single equal to total/3 also add one to part . Complexity Time Complexity O(n) Space Complexity O(1) Special test case [1,-1,1,-1] => Sum is zero will cause sum % (total/3) get divided by zero exception [1,1,1,1] Code class Solution { public: bool canThreePartsEqualSum(vector<int>& arr) { int total = std::accumulate(arr.begin(), arr.end(), 0); //O(n) int sz = arr.size(); int sum = 0, part = 0; if (total%3 != 0) return false; for (int i=0; i<sz; i++) { sum += arr[i]; if (sum == total/3) { part++; sum=0; } } return part >= 3; // '>=' is used to filter out a single value which satisfied `sum==total/3` that will increase the value of part } };","title":"1013. Partition Array Into Three Parts With Equal Sum"},{"location":"array/partition_array_into_three_parts_with_equal_sum/#1013-partition-array-into-three-parts-with-equal-sum","text":"Source Topic : Array, Greedy Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums. Formally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]) Constraints 3 <= arr.length <= 5 * 104 -104 <= arr[i] <= 104","title":"1013. Partition Array Into Three Parts With Equal Sum"},{"location":"array/partition_array_into_three_parts_with_equal_sum/#concept","text":"The basic idea is to sum up a range of value and check if it is equal to total/3 , we'll Increase part variable if the condiction meet. Finally, return true if part>=3 , why? Because every single equal to total/3 also add one to part .","title":"Concept"},{"location":"array/partition_array_into_three_parts_with_equal_sum/#complexity","text":"Time Complexity O(n) Space Complexity O(1)","title":"Complexity"},{"location":"array/partition_array_into_three_parts_with_equal_sum/#special-test-case","text":"[1,-1,1,-1] => Sum is zero will cause sum % (total/3) get divided by zero exception [1,1,1,1]","title":"Special test case"},{"location":"array/partition_array_into_three_parts_with_equal_sum/#code","text":"class Solution { public: bool canThreePartsEqualSum(vector<int>& arr) { int total = std::accumulate(arr.begin(), arr.end(), 0); //O(n) int sz = arr.size(); int sum = 0, part = 0; if (total%3 != 0) return false; for (int i=0; i<sz; i++) { sum += arr[i]; if (sum == total/3) { part++; sum=0; } } return part >= 3; // '>=' is used to filter out a single value which satisfied `sum==total/3` that will increase the value of part } };","title":"Code"},{"location":"binary_search/guess_number_higher_or_lower/","text":"374. Guess Number Higher or Lower Source Topic : Binary Search We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API int guess(int num), which returns three possible results: -1: Your guess is higher than the number I picked (i.e. num > pick). 1: Your guess is lower than the number I picked (i.e. num < pick). 0: your guess is equal to the number I picked (i.e. num == pick). Return the number that I picked. Constraints 1 <= n <= 231 - 1 1 <= pick <= n Concept The idea is similar to Binary Search because we'll move the mid based on what guess() return, when: guess(m) > 0 => set l = m+1 guess(m) < 0 => set r = m-1 guess(m) == 0 => Found answer We could use the condition while(l<=r) or while(true) because we're ensure to find answer. Complexity Time Complexity O(logn) Space Complexity O(1) Special test case 2126753390 1702766719 The above case will cause buffer overflow exception if our expression is (r+l)/2 . Code /** * Forward declaration of guess API. * @param num your guess * @return -1 if num is lower than the guess number * 1 if num is higher than the guess number * otherwise return 0 * int guess(int num); */ class Solution { public: int guessNumber(int n) { int l=0, r=n; while (l<=r) { int m = (r-l)/2 + l; // Note: (r+l)/2 will cause buffer overflow exception int ret = guess(m); if (ret > 0) l = m+1; else if (ret < 0) r = m-1; else return m; } return -1; } };","title":"374. Guess Number Higher or Lower"},{"location":"binary_search/guess_number_higher_or_lower/#374-guess-number-higher-or-lower","text":"Source Topic : Binary Search We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API int guess(int num), which returns three possible results: -1: Your guess is higher than the number I picked (i.e. num > pick). 1: Your guess is lower than the number I picked (i.e. num < pick). 0: your guess is equal to the number I picked (i.e. num == pick). Return the number that I picked. Constraints 1 <= n <= 231 - 1 1 <= pick <= n","title":"374. Guess Number Higher or Lower"},{"location":"binary_search/guess_number_higher_or_lower/#concept","text":"The idea is similar to Binary Search because we'll move the mid based on what guess() return, when: guess(m) > 0 => set l = m+1 guess(m) < 0 => set r = m-1 guess(m) == 0 => Found answer We could use the condition while(l<=r) or while(true) because we're ensure to find answer.","title":"Concept"},{"location":"binary_search/guess_number_higher_or_lower/#complexity","text":"Time Complexity O(logn) Space Complexity O(1)","title":"Complexity"},{"location":"binary_search/guess_number_higher_or_lower/#special-test-case","text":"2126753390 1702766719 The above case will cause buffer overflow exception if our expression is (r+l)/2 .","title":"Special test case"},{"location":"binary_search/guess_number_higher_or_lower/#code","text":"/** * Forward declaration of guess API. * @param num your guess * @return -1 if num is lower than the guess number * 1 if num is higher than the guess number * otherwise return 0 * int guess(int num); */ class Solution { public: int guessNumber(int n) { int l=0, r=n; while (l<=r) { int m = (r-l)/2 + l; // Note: (r+l)/2 will cause buffer overflow exception int ret = guess(m); if (ret > 0) l = m+1; else if (ret < 0) r = m-1; else return m; } return -1; } };","title":"Code"},{"location":"dp/jump_game/","text":"Jump Game Source You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 105 Concept The idea is to iterate entire loop and set variable reach by max(reach, i+nums[i]) , when the indexer i exceed reach which means we couldn't jump to the end with current value. Code class Solution { public: bool canJump(vector<int>& nums) { /** 2022/1/6 -- O(N), O(1); Greedy */ int n = nums.size(); if (n == 1) return true; int i = 0; for (int reach=0; i<n && i<=reach; i++) { // We add `i<=reach` to let i escape from loop earlier reach = max(reach, i+nums[i]); } return i == n; } };","title":"55. Jump Game"},{"location":"dp/jump_game/#jump-game","text":"Source You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 105","title":"Jump Game"},{"location":"dp/jump_game/#concept","text":"The idea is to iterate entire loop and set variable reach by max(reach, i+nums[i]) , when the indexer i exceed reach which means we couldn't jump to the end with current value.","title":"Concept"},{"location":"dp/jump_game/#code","text":"class Solution { public: bool canJump(vector<int>& nums) { /** 2022/1/6 -- O(N), O(1); Greedy */ int n = nums.size(); if (n == 1) return true; int i = 0; for (int reach=0; i<n && i<=reach; i++) { // We add `i<=reach` to let i escape from loop earlier reach = max(reach, i+nums[i]); } return i == n; } };","title":"Code"},{"location":"dp/jump_game2/","text":"Jump Game II Source Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. You can assume that you can always reach the last index. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 1000 Concept: Code:","title":"45. Jump Game II"},{"location":"dp/jump_game2/#jump-game-ii","text":"Source Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. You can assume that you can always reach the last index. Constraints 1 <= nums.length <= 104 0 <= nums[i] <= 1000","title":"Jump Game II"},{"location":"dp/jump_game2/#concept","text":"","title":"Concept:"},{"location":"dp/jump_game2/#code","text":"","title":"Code:"},{"location":"dp/linked_list_cycle2/","text":"142. Linked List Cycle II Source Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. Constraints The number of the nodes in the list is in the range [0, 104]. -105 <= Node.val <= 105 pos is -1 or a valid index in the linked-list. Concept: O(1) space complexity Since. (2S = F) consider the part from start - cycle point = A, cycle point- intersect = B, intersect - cycle point = C then slow trival A + B fast travel A + (B+C) * N + B (B+C) is one cycle and * N number we travel the cycles from 2S = F we know (B+C)*N = A + B from (B+C)*N = A + B if we remove B from each side B * (N-1) + C * N = A. then A must be equal to C or eqaul to X * C + Y * B where (X - Y = 1) In other words A mod(B+C) = C. A = B(N-1)+CN =B(N-1)+C(N-1)+C=(B+C)(N-1)+C As a result when we travel from start to point takes A to cycle points and Intersect to cycle points will be same distance or travel M cycles then reach to cycle points (from A mod(b+c) = C); (thats is why we set 1 ptr at start and 1 at intersect and trival at same rate.) Code: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (slow && fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow==fast) { ListNode *start = head; while (slow != start) { start = start->next; slow = slow->next; } return start; } } return nullptr; } };","title":"142. Linked List Cycle II"},{"location":"dp/linked_list_cycle2/#142-linked-list-cycle-ii","text":"Source Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. Constraints The number of the nodes in the list is in the range [0, 104]. -105 <= Node.val <= 105 pos is -1 or a valid index in the linked-list.","title":"142. Linked List Cycle II"},{"location":"dp/linked_list_cycle2/#concept","text":"O(1) space complexity Since. (2S = F) consider the part from start - cycle point = A, cycle point- intersect = B, intersect - cycle point = C then slow trival A + B fast travel A + (B+C) * N + B (B+C) is one cycle and * N number we travel the cycles from 2S = F we know (B+C)*N = A + B from (B+C)*N = A + B if we remove B from each side B * (N-1) + C * N = A. then A must be equal to C or eqaul to X * C + Y * B where (X - Y = 1) In other words A mod(B+C) = C. A = B(N-1)+CN =B(N-1)+C(N-1)+C=(B+C)(N-1)+C As a result when we travel from start to point takes A to cycle points and Intersect to cycle points will be same distance or travel M cycles then reach to cycle points (from A mod(b+c) = C); (thats is why we set 1 ptr at start and 1 at intersect and trival at same rate.)","title":"Concept:"},{"location":"dp/linked_list_cycle2/#code","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (slow && fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow==fast) { ListNode *start = head; while (slow != start) { start = start->next; slow = slow->next; } return start; } } return nullptr; } };","title":"Code:"},{"location":"dp/minimum_path_sum/","text":"64. Minimum Path Sum Source Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Constraints m == grid.length n == grid[i].length 1 <= m, n <= 200 0 <= grid[i][j] <= 100 Concept The idea is similar to Unique Paths problem, but we use a two dimension array with size m+1 x n+1. The reason that adding one to m & n is to compare value between extended cell with incoming grid. What we do to find out the solution is implement as below: Create a two dimension array a[m+1][n+1] Initialize the last row and column to all INT_MAX . (Here is a common straegy to find out the minimum from two values.) Set a[m][n-1] to zero because we want to get the smallest value in the first time. Iterate cell starting from the last cell in the grid. Find out the smaller value from the two adjacent nodes(right/down) and plus current cell. Repeat this step until we reach the first cell in the grid. The final answer is in a[0][0] Complexity Time Complexity O(m*n): We iterate the table, the size of table is m rows multiplies n * columns. Space Complexity O(m*n): An extra space to hold the value when calculating the minimum path. Code class Solution { public: int minPathSum(vector<vector<int>>& grid) { /** 2022/1/7 -- 8ms, 9.8mb; O(m*n), O(m*n); DP, Copy cat */ int m = grid.size(), n = grid[0].size(); int rec[m+1][n+1]; for (int i=0; i<n; i++) rec[m][i] = INT_MAX; for (int i=0; i<m; i++) rec[i][n] = INT_MAX; rec[m][n-1] = 0; // Either `rec[m][n-1] = 0` or `rec[m-1][n] = 0` could let the min() work. for (int i=m-1; i>=0; i--) { for (int j=n-1; j>=0; j--) { rec[i][j] = grid[i][j] + min(rec[i+1][j], rec[i][j+1]); } } return rec[0][0]; } };","title":"64. Minimum Path Sum"},{"location":"dp/minimum_path_sum/#64-minimum-path-sum","text":"Source Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Constraints m == grid.length n == grid[i].length 1 <= m, n <= 200 0 <= grid[i][j] <= 100","title":"64. Minimum Path Sum"},{"location":"dp/minimum_path_sum/#concept","text":"The idea is similar to Unique Paths problem, but we use a two dimension array with size m+1 x n+1. The reason that adding one to m & n is to compare value between extended cell with incoming grid. What we do to find out the solution is implement as below: Create a two dimension array a[m+1][n+1] Initialize the last row and column to all INT_MAX . (Here is a common straegy to find out the minimum from two values.) Set a[m][n-1] to zero because we want to get the smallest value in the first time. Iterate cell starting from the last cell in the grid. Find out the smaller value from the two adjacent nodes(right/down) and plus current cell. Repeat this step until we reach the first cell in the grid. The final answer is in a[0][0]","title":"Concept"},{"location":"dp/minimum_path_sum/#complexity","text":"Time Complexity O(m*n): We iterate the table, the size of table is m rows multiplies n * columns. Space Complexity O(m*n): An extra space to hold the value when calculating the minimum path.","title":"Complexity"},{"location":"dp/minimum_path_sum/#code","text":"class Solution { public: int minPathSum(vector<vector<int>>& grid) { /** 2022/1/7 -- 8ms, 9.8mb; O(m*n), O(m*n); DP, Copy cat */ int m = grid.size(), n = grid[0].size(); int rec[m+1][n+1]; for (int i=0; i<n; i++) rec[m][i] = INT_MAX; for (int i=0; i<m; i++) rec[i][n] = INT_MAX; rec[m][n-1] = 0; // Either `rec[m][n-1] = 0` or `rec[m-1][n] = 0` could let the min() work. for (int i=m-1; i>=0; i--) { for (int j=n-1; j>=0; j--) { rec[i][j] = grid[i][j] + min(rec[i+1][j], rec[i][j+1]); } } return rec[0][0]; } };","title":"Code"},{"location":"dp/unique_binary_search_trees/","text":"96. Unique Binary Search Trees Source Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. Constraints 1 <= n <= 19 Concept: The idea is to solve sub problem in dynamic programming. When n = 0 or n = 1 , there's 1 possible BST exists. But when the n >= 2 that means we could break down this problem into sub problem as below: n==2: left nodes + root + right nodes 2 1 / or \\ 1 2 So we can turn this problem into Find out the combination while iterate the nodes, the formula of each combination will be numTrees(left) * numTrees(right) , then we can sum up the number because we want to know how many unique BST exists for N. Complexity Time Complexity O(n^2): We have a nested for-loop inside because we need to move root node. Space Complexity O(n): Extra space to hold the number of unique BST of N. Code: class Solution { public: int numTrees(int n) { if (n<=1) return 1; vector<int> dp(n+1, 1); // 0-> 1; 1->1 for (int nodes=2; nodes<=n; nodes++) { int total = 0; for (int root=1; root<=nodes; root++) { int left = root - 1; int right = nodes - root; total += dp[left] * dp[right]; } dp[nodes] = total; } return dp.back(); } };","title":"96. Unique Binary Search Trees"},{"location":"dp/unique_binary_search_trees/#96-unique-binary-search-trees","text":"Source Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. Constraints 1 <= n <= 19","title":"96. Unique Binary Search Trees"},{"location":"dp/unique_binary_search_trees/#concept","text":"The idea is to solve sub problem in dynamic programming. When n = 0 or n = 1 , there's 1 possible BST exists. But when the n >= 2 that means we could break down this problem into sub problem as below: n==2: left nodes + root + right nodes 2 1 / or \\ 1 2 So we can turn this problem into Find out the combination while iterate the nodes, the formula of each combination will be numTrees(left) * numTrees(right) , then we can sum up the number because we want to know how many unique BST exists for N.","title":"Concept:"},{"location":"dp/unique_binary_search_trees/#complexity","text":"Time Complexity O(n^2): We have a nested for-loop inside because we need to move root node. Space Complexity O(n): Extra space to hold the number of unique BST of N.","title":"Complexity"},{"location":"dp/unique_binary_search_trees/#code","text":"class Solution { public: int numTrees(int n) { if (n<=1) return 1; vector<int> dp(n+1, 1); // 0-> 1; 1->1 for (int nodes=2; nodes<=n; nodes++) { int total = 0; for (int root=1; root<=nodes; root++) { int left = root - 1; int right = nodes - root; total += dp[left] * dp[right]; } dp[nodes] = total; } return dp.back(); } };","title":"Code:"},{"location":"dp/unique_paths/","text":"62. Unique Paths Source There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. Constraints 1 <= m, n <= 100 Concept: 28 21 15 10 6 3 1 7 6 5 4 3 2 1 1 1 1 1 1 1 1 The idea is is to solve sub problem start from the bottom-right: Create a 2D array to hold every possible path to the desitination. Set the value of bottom row to all 1 because there's only one way to each cell. Sum up the value in right & bottom of each cell => It shows how much ways to the destination starting from current cell. We'd get final answer at grid[0][0] Complexity Time Complexity O(m*n): We iterate the table, the size of table is m rows multiplies n * columns. Space Complexity O(n): We use a vector to hold the date of previous row, and update it when we finish iterating current row. Code: class Solution { public: int uniquePaths(int m, int n) { /** 2022/1/6 -- 7ms, 6.3mb; O(m*n), O(n); DP */ vector<int> vx(n, 1); // n * 1 for (int i=0; i<m-1; i++) { // Because we've set the bottom row to all 1 vector<int> vNew(n, 1); // Since we want the last element become 1 for (int j=n-2; j>=0; j--) { // Because the last column is always 1 vNew[j] = vNew[j+1] + vx[j]; } vx.assign(vNew.begin(), vNew.end()); } return vx[0]; } };","title":"62. Unique Paths"},{"location":"dp/unique_paths/#62-unique-paths","text":"Source There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. Constraints 1 <= m, n <= 100","title":"62. Unique Paths"},{"location":"dp/unique_paths/#concept","text":"28 21 15 10 6 3 1 7 6 5 4 3 2 1 1 1 1 1 1 1 1 The idea is is to solve sub problem start from the bottom-right: Create a 2D array to hold every possible path to the desitination. Set the value of bottom row to all 1 because there's only one way to each cell. Sum up the value in right & bottom of each cell => It shows how much ways to the destination starting from current cell. We'd get final answer at grid[0][0]","title":"Concept:"},{"location":"dp/unique_paths/#complexity","text":"Time Complexity O(m*n): We iterate the table, the size of table is m rows multiplies n * columns. Space Complexity O(n): We use a vector to hold the date of previous row, and update it when we finish iterating current row.","title":"Complexity"},{"location":"dp/unique_paths/#code","text":"class Solution { public: int uniquePaths(int m, int n) { /** 2022/1/6 -- 7ms, 6.3mb; O(m*n), O(n); DP */ vector<int> vx(n, 1); // n * 1 for (int i=0; i<m-1; i++) { // Because we've set the bottom row to all 1 vector<int> vNew(n, 1); // Since we want the last element become 1 for (int j=n-2; j>=0; j--) { // Because the last column is always 1 vNew[j] = vNew[j+1] + vx[j]; } vx.assign(vNew.begin(), vNew.end()); } return vx[0]; } };","title":"Code:"},{"location":"hash_table/contains_duplicate2/","text":"219. Contains Duplicate II Source Topic : Hash Table, Sliding Window Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k. Constraints 1 <= nums.length <= 105 -109 <= nums[i] <= 109 0 <= k <= 105 Concept Map Unlikely to #217, we set the offset as the value rather than occurence, so we can add or update the offset if the key is not exist. Otherwise, we can calculate the difference from current index to mp[nums[i]] , and return true if it's less than k . Set Using set as a container to simulate the sliding window because we only care about those value index i to i-k+1 , so the key point is to erase the out bound value by st.erase(nums[i-k-1]) . The reason to specify a value with offset i-k-1 is because the insert operation will put new value at the front of container, so we can't erase the first. Complexity Time Complexity Map: O(n) Set: O(n), either st.erase & outer loop may take linear time complexity. Space Complexity Map: O(n) Set: O(n) Special test case Code Map bool containsNearbyDuplicate(vector<int>& nums, int k) { map<int, int> mp; int len = nums.size(); for (int i=0; i<len; i++) { int v = nums[i]; if (!mp.count(v) || i-mp[v]>k) mp[nums[i]] = i; else return true; } return false; } Set bool containsNearbyDuplicate(vector<int>& nums, int k) { int len = nums.size(); unordered_set<int> st; for (int i=0; i<len; i++) { if (i>k) st.erase(nums[i-k-1]); if (st.find(nums[i]) != st.end()) return true; st.insert(nums[i]); } return false; }","title":"219. Contains Duplicate II"},{"location":"hash_table/contains_duplicate2/#219-contains-duplicate-ii","text":"Source Topic : Hash Table, Sliding Window Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k. Constraints 1 <= nums.length <= 105 -109 <= nums[i] <= 109 0 <= k <= 105","title":"219. Contains Duplicate II"},{"location":"hash_table/contains_duplicate2/#concept","text":"Map Unlikely to #217, we set the offset as the value rather than occurence, so we can add or update the offset if the key is not exist. Otherwise, we can calculate the difference from current index to mp[nums[i]] , and return true if it's less than k . Set Using set as a container to simulate the sliding window because we only care about those value index i to i-k+1 , so the key point is to erase the out bound value by st.erase(nums[i-k-1]) . The reason to specify a value with offset i-k-1 is because the insert operation will put new value at the front of container, so we can't erase the first.","title":"Concept"},{"location":"hash_table/contains_duplicate2/#complexity","text":"Time Complexity Map: O(n) Set: O(n), either st.erase & outer loop may take linear time complexity. Space Complexity Map: O(n) Set: O(n)","title":"Complexity"},{"location":"hash_table/contains_duplicate2/#special-test-case","text":"","title":"Special test case"},{"location":"hash_table/contains_duplicate2/#code","text":"Map bool containsNearbyDuplicate(vector<int>& nums, int k) { map<int, int> mp; int len = nums.size(); for (int i=0; i<len; i++) { int v = nums[i]; if (!mp.count(v) || i-mp[v]>k) mp[nums[i]] = i; else return true; } return false; } Set bool containsNearbyDuplicate(vector<int>& nums, int k) { int len = nums.size(); unordered_set<int> st; for (int i=0; i<len; i++) { if (i>k) st.erase(nums[i-k-1]); if (st.find(nums[i]) != st.end()) return true; st.insert(nums[i]); } return false; }","title":"Code"},{"location":"hash_table/group_anagrams/","text":"49. Group Anagrams Source Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Constraints 1 <= strs.length <= 104 0 <= strs[i].length <= 100 strs[i] consists of lowercase English letters. Concept Sorting The idea is to sort incoming string and set as a key in the map. Once we find out a key exists, then append the orginal string to the value. Complexity Time Complexity O(n * klogk): n is the lenght of strs and k is the string size. Space Complexity O(n * k) Code class Solution { public: vector<vector<string>> groupAnagrams(vector<string>& strs) { vector<vector<string>> ans; unordered_map<string, vector<string>> m; for (auto s : strs) { string s1 = s; sort(s1.begin(), s1.end()); m[s1].push_back(s); } for (auto x : m) { ans.push_back(x.second); } return ans; } };","title":"49. Group Anagrams"},{"location":"hash_table/group_anagrams/#49-group-anagrams","text":"Source Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Constraints 1 <= strs.length <= 104 0 <= strs[i].length <= 100 strs[i] consists of lowercase English letters.","title":"49. Group Anagrams"},{"location":"hash_table/group_anagrams/#concept","text":"Sorting The idea is to sort incoming string and set as a key in the map. Once we find out a key exists, then append the orginal string to the value.","title":"Concept"},{"location":"hash_table/group_anagrams/#complexity","text":"Time Complexity O(n * klogk): n is the lenght of strs and k is the string size. Space Complexity O(n * k)","title":"Complexity"},{"location":"hash_table/group_anagrams/#code","text":"class Solution { public: vector<vector<string>> groupAnagrams(vector<string>& strs) { vector<vector<string>> ans; unordered_map<string, vector<string>> m; for (auto s : strs) { string s1 = s; sort(s1.begin(), s1.end()); m[s1].push_back(s); } for (auto x : m) { ans.push_back(x.second); } return ans; } };","title":"Code"},{"location":"math/add_two_numbers/","text":"2. Add Two Numbers Source You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Constraints The number of nodes in each linked list is in the range [1, 100]. 0 <= Node.val <= 9 It is guaranteed that the list represents a number that does not have leading zeros. Concept: Algorithm: Create a dummy node and a pointer curr which point to the dummy node. Create a variable carry as a flag to know if there's a carry bit been set. Visit l1 & l2 iterately, sum up l1 or l2 if it's not null. We need to add carry if it present' Update the carry flag by set carry=sum/10 every time. Create a new node with value tmp%10 and let curr point to that address. Move pointer curr to the next by curr = curr->next Repeart until l1 & l2 are visited both. Remember to create a new node if the carry flag is set. Complexity Time Complexity O(n): Where n is max(l1.length, l2.length). Space Complexity O(n): Where n is max(l1.length, l2.length). Code: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *p=l1, *q=l2, *dummy, *curr; int carry=0; dummy = new ListNode(); curr = dummy; // a pointer to the dummy node while (p || q) { int tmp = 0 + carry; if (p) tmp += p->val; if (q) tmp += q->val; carry = tmp/10; curr->next = new ListNode(tmp%10); // make link to the dummy curr = curr->next; // move curr pointer to next one if (p) p = p->next; if (q) q = q->next; } if (carry) // ethier 0 or 1 curr->next = new ListNode(carry); return dummy->next; } };","title":"2. Add Two Numbers"},{"location":"math/add_two_numbers/#2-add-two-numbers","text":"Source You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Constraints The number of nodes in each linked list is in the range [1, 100]. 0 <= Node.val <= 9 It is guaranteed that the list represents a number that does not have leading zeros.","title":"2. Add Two Numbers"},{"location":"math/add_two_numbers/#concept","text":"Algorithm: Create a dummy node and a pointer curr which point to the dummy node. Create a variable carry as a flag to know if there's a carry bit been set. Visit l1 & l2 iterately, sum up l1 or l2 if it's not null. We need to add carry if it present' Update the carry flag by set carry=sum/10 every time. Create a new node with value tmp%10 and let curr point to that address. Move pointer curr to the next by curr = curr->next Repeart until l1 & l2 are visited both. Remember to create a new node if the carry flag is set.","title":"Concept:"},{"location":"math/add_two_numbers/#complexity","text":"Time Complexity O(n): Where n is max(l1.length, l2.length). Space Complexity O(n): Where n is max(l1.length, l2.length).","title":"Complexity"},{"location":"math/add_two_numbers/#code","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *p=l1, *q=l2, *dummy, *curr; int carry=0; dummy = new ListNode(); curr = dummy; // a pointer to the dummy node while (p || q) { int tmp = 0 + carry; if (p) tmp += p->val; if (q) tmp += q->val; carry = tmp/10; curr->next = new ListNode(tmp%10); // make link to the dummy curr = curr->next; // move curr pointer to next one if (p) p = p->next; if (q) q = q->next; } if (carry) // ethier 0 or 1 curr->next = new ListNode(carry); return dummy->next; } };","title":"Code:"},{"location":"math/nim_game/","text":"292. Nim Game Source You are playing the following Nim Game with your friend: Initially, there is a heap of stones on the table. You and your friend will alternate taking turns, and you go first. On each turn, the person whose turn it is will remove 1 to 3 stones from the heap. The one who removes the last stone is the winner. Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false. Constraints 1 <= n <= 231 - 1 Concept Because you could take either 1 or 2 or 3 stones each time, so you win the game when the total number of stones less than 4. Why does this matter? Consider the case that there are 5-7 stones on the table, and we could pick 1 / 2 / 3 respectively to let the number of the rest stones to 4, but you could NOT win when the number is 4 or 8, so we could assume that the number is not divisible by 4 is the answer. Complexity Time Complexity O(1) Space Complexity O(1) Code class Solution { public: bool canWinNim(int n) { return n&3; // or return n%4 != 0; } };","title":"292. Nim Game"},{"location":"math/nim_game/#292-nim-game","text":"Source You are playing the following Nim Game with your friend: Initially, there is a heap of stones on the table. You and your friend will alternate taking turns, and you go first. On each turn, the person whose turn it is will remove 1 to 3 stones from the heap. The one who removes the last stone is the winner. Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false. Constraints 1 <= n <= 231 - 1","title":"292. Nim Game"},{"location":"math/nim_game/#concept","text":"Because you could take either 1 or 2 or 3 stones each time, so you win the game when the total number of stones less than 4. Why does this matter? Consider the case that there are 5-7 stones on the table, and we could pick 1 / 2 / 3 respectively to let the number of the rest stones to 4, but you could NOT win when the number is 4 or 8, so we could assume that the number is not divisible by 4 is the answer.","title":"Concept"},{"location":"math/nim_game/#complexity","text":"Time Complexity O(1) Space Complexity O(1)","title":"Complexity"},{"location":"math/nim_game/#code","text":"class Solution { public: bool canWinNim(int n) { return n&3; // or return n%4 != 0; } };","title":"Code"},{"location":"math/reverse_integer/","text":"7. Reverse Integer Source Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0. Assume the environment does not allow you to store 64-bit integers (signed or unsigned). Constraints -231 <= x <= 231 - 1 Concept The limitation that you could NOT use a long or long long to store a temporary data, so we might consider the edge case that could prevent overflow or underflow during checking each digit, the algorithm will be: Detect the input value is negative or not and use a flag to hold it. Set the absolute value of x to y to make the codes easy to implement. Check the y>0 iterately and get remaining r . Calculate the temporary answer by v = v*10 +r , but the key point is: if v > INT_MAX/10 , return 0 if v == INT_MAX/10 && r > 7 , return 0 Return the correct answer with previous sign flag. Why we need to return 0 in some condition? It's because any number larger than INT_MAX/10 cannot be multipied by 10 or it would get overflow exception. Complexity Time Complexity O(log(n)): It's roughly equal log 10 (n). Space Complexity O(1) Code class Solution { public: int reverse(int x) { int v=0; int sign = x>=0; int y = abs(x); while (y>0) { int r = y%10; if (v > INT_MAX/10) // v >= 214748365 return 0; if (v==INT_MAX/10 && r>7) // v >= 214748364 && r > 7 return 0; v = v*10 + r; y /= 10; } return sign ? v : 0-v; } };","title":"7. Reverse Integer"},{"location":"math/reverse_integer/#7-reverse-integer","text":"Source Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0. Assume the environment does not allow you to store 64-bit integers (signed or unsigned). Constraints -231 <= x <= 231 - 1","title":"7. Reverse Integer"},{"location":"math/reverse_integer/#concept","text":"The limitation that you could NOT use a long or long long to store a temporary data, so we might consider the edge case that could prevent overflow or underflow during checking each digit, the algorithm will be: Detect the input value is negative or not and use a flag to hold it. Set the absolute value of x to y to make the codes easy to implement. Check the y>0 iterately and get remaining r . Calculate the temporary answer by v = v*10 +r , but the key point is: if v > INT_MAX/10 , return 0 if v == INT_MAX/10 && r > 7 , return 0 Return the correct answer with previous sign flag. Why we need to return 0 in some condition? It's because any number larger than INT_MAX/10 cannot be multipied by 10 or it would get overflow exception.","title":"Concept"},{"location":"math/reverse_integer/#complexity","text":"Time Complexity O(log(n)): It's roughly equal log 10 (n). Space Complexity O(1)","title":"Complexity"},{"location":"math/reverse_integer/#code","text":"class Solution { public: int reverse(int x) { int v=0; int sign = x>=0; int y = abs(x); while (y>0) { int r = y%10; if (v > INT_MAX/10) // v >= 214748365 return 0; if (v==INT_MAX/10 && r>7) // v >= 214748364 && r > 7 return 0; v = v*10 + r; y /= 10; } return sign ? v : 0-v; } };","title":"Code"},{"location":"math/third_maximum_number/","text":"414. Third Maximum Number Source Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number. Follow up: Can you find an O(n) solution? Constraints 1 <= nums.length <= 104 -231 <= nums[i] <= 231 - 1 Concept The idea is to find out the top three numbers in one pass algorithm, but we need to take care of the 3rd largest number might INT_MIN . So we use long long as the data type of a vector, and intialize its data to LLONG_MIN . Create a vector vector<long long> vx(3, LLONG_MIN) Iterately compare the number between nums and vx We need to keep the order inside vx if we find a number is larger than any digit in vx Since we initialized data to LLONG_MIN previosuly, so we can return vx[0] (max) if vx[2] is LLONG_MIN which means there's no 3rd biggest number exist. Complexity Time Complexity O(n) Space Complexity O(1) Code class Solution { public: int thirdMax(vector<int>& nums) { vector<long long> vx(3, LLONG_MIN); for (int i=0; i<nums.size(); i++) { if (find(vx.begin(), vx.end(), nums[i]) != vx.end()) continue; if (nums[i] > vx[0]) vx = {nums[i], vx[0], vx[1]}; else if (nums[i] > vx[1]) vx = {vx[0], nums[i], vx[1]}; else if (nums[i] > vx[2]) vx = {vx[0], vx[1], nums[i]}; } return vx[2]==LLONG_MIN ? vx[0] : vx[2]; } };","title":"414. Third Maximum Number"},{"location":"math/third_maximum_number/#414-third-maximum-number","text":"Source Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number. Follow up: Can you find an O(n) solution? Constraints 1 <= nums.length <= 104 -231 <= nums[i] <= 231 - 1","title":"414. Third Maximum Number"},{"location":"math/third_maximum_number/#concept","text":"The idea is to find out the top three numbers in one pass algorithm, but we need to take care of the 3rd largest number might INT_MIN . So we use long long as the data type of a vector, and intialize its data to LLONG_MIN . Create a vector vector<long long> vx(3, LLONG_MIN) Iterately compare the number between nums and vx We need to keep the order inside vx if we find a number is larger than any digit in vx Since we initialized data to LLONG_MIN previosuly, so we can return vx[0] (max) if vx[2] is LLONG_MIN which means there's no 3rd biggest number exist.","title":"Concept"},{"location":"math/third_maximum_number/#complexity","text":"Time Complexity O(n) Space Complexity O(1)","title":"Complexity"},{"location":"math/third_maximum_number/#code","text":"class Solution { public: int thirdMax(vector<int>& nums) { vector<long long> vx(3, LLONG_MIN); for (int i=0; i<nums.size(); i++) { if (find(vx.begin(), vx.end(), nums[i]) != vx.end()) continue; if (nums[i] > vx[0]) vx = {nums[i], vx[0], vx[1]}; else if (nums[i] > vx[1]) vx = {vx[0], nums[i], vx[1]}; else if (nums[i] > vx[2]) vx = {vx[0], vx[1], nums[i]}; } return vx[2]==LLONG_MIN ? vx[0] : vx[2]; } };","title":"Code"},{"location":"math/two_sum/","text":"1. Two Sum Source Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity? Constraints 2 <= nums.length <= 104 -109 <= nums[i] <= 109 -109 <= target <= 109 Only one valid answer exists. Concept Because the limitation is to implement a algorithm which time complexity is less O(n^2), so we use an extra space to keep track of indice in a map. Then we iterately check if the complement exists in the map. Complexity Time Complexity O(n): We only visit each element one time in the worst case. Space Complexity O(n): We use an extra space to map the complement and index. Code class Solution { public: vector<int> twoSum(vector<int>& nums, int target) { map<int, int> m; for (int i=0; i<nums.size(); i++) { int diff = target - nums[i]; if (m.count(diff) > 0) return {m[diff], i}; m[nums[i]] = i; } return {}; } };","title":"1. Two Sum"},{"location":"math/two_sum/#1-two-sum","text":"Source Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity? Constraints 2 <= nums.length <= 104 -109 <= nums[i] <= 109 -109 <= target <= 109 Only one valid answer exists.","title":"1. Two Sum"},{"location":"math/two_sum/#concept","text":"Because the limitation is to implement a algorithm which time complexity is less O(n^2), so we use an extra space to keep track of indice in a map. Then we iterately check if the complement exists in the map.","title":"Concept"},{"location":"math/two_sum/#complexity","text":"Time Complexity O(n): We only visit each element one time in the worst case. Space Complexity O(n): We use an extra space to map the complement and index.","title":"Complexity"},{"location":"math/two_sum/#code","text":"class Solution { public: vector<int> twoSum(vector<int>& nums, int target) { map<int, int> m; for (int i=0; i<nums.size(); i++) { int diff = target - nums[i]; if (m.count(diff) > 0) return {m[diff], i}; m[nums[i]] = i; } return {}; } };","title":"Code"},{"location":"sliding_window/longest_repeating_character_replacement/","text":"424. Longest Repeating Character Replacement Source Topic : Sliding Window, Hash Table, String You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations. Constraints 1 <= s.length <= 105 s consists of only uppercase English letters. 0 <= k <= s.length Concept Sliding Window We use l & r as the bound of a window, the main idea is to check if Window_Size - the number of majority <= k , why? Since there's only k chances that we can replace characters, so a valid window will have the number which less than k for replacement. How do we find the maxmimum lenght of a repeating string? Use a variable res to keep track of the max value and update the result only when a valid window size is more than res . Complexity Time Complexity O(n): n is equal to string length. Space Complexity O(1): the worst case will be n=26 becasue there're 26 distinct characters in the string. Special test case Code class Solution { public: static bool compare(const pair<char, int>& a, const pair<char, int>& b){ return a.second <= b.second; } int characterReplacement(string s, int k) { int l=0, r=0, res=0; map<char, int> m; // key: character, value: frequency int maxf=0; for (auto c : s) { int winLen = r-l+1; m[c]++; maxf = max(maxf, m[c]); // while (winLen - max_element(m.begin(), m.end(), compare)->second > k) { while (winLen - maxf > k) { // Use maxf instead of searching from map m[s[l]]--; l++; winLen = r-l+1; } res = max(res, winLen); r++; } return res; } };","title":"424. Longest Repeating Character Replacement"},{"location":"sliding_window/longest_repeating_character_replacement/#424-longest-repeating-character-replacement","text":"Source Topic : Sliding Window, Hash Table, String You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations. Constraints 1 <= s.length <= 105 s consists of only uppercase English letters. 0 <= k <= s.length","title":"424. Longest Repeating Character Replacement"},{"location":"sliding_window/longest_repeating_character_replacement/#concept","text":"Sliding Window We use l & r as the bound of a window, the main idea is to check if Window_Size - the number of majority <= k , why? Since there's only k chances that we can replace characters, so a valid window will have the number which less than k for replacement. How do we find the maxmimum lenght of a repeating string? Use a variable res to keep track of the max value and update the result only when a valid window size is more than res .","title":"Concept"},{"location":"sliding_window/longest_repeating_character_replacement/#complexity","text":"Time Complexity O(n): n is equal to string length. Space Complexity O(1): the worst case will be n=26 becasue there're 26 distinct characters in the string.","title":"Complexity"},{"location":"sliding_window/longest_repeating_character_replacement/#special-test-case","text":"","title":"Special test case"},{"location":"sliding_window/longest_repeating_character_replacement/#code","text":"class Solution { public: static bool compare(const pair<char, int>& a, const pair<char, int>& b){ return a.second <= b.second; } int characterReplacement(string s, int k) { int l=0, r=0, res=0; map<char, int> m; // key: character, value: frequency int maxf=0; for (auto c : s) { int winLen = r-l+1; m[c]++; maxf = max(maxf, m[c]); // while (winLen - max_element(m.begin(), m.end(), compare)->second > k) { while (winLen - maxf > k) { // Use maxf instead of searching from map m[s[l]]--; l++; winLen = r-l+1; } res = max(res, winLen); r++; } return res; } };","title":"Code"},{"location":"snippet/random_negative_int/","text":"Generate random number contains negative values int a = (rand() % 2000) - 1000; // -1000 ~ 999","title":"Generate random negative integer"},{"location":"snippet/random_negative_int/#generate-random-number-contains-negative-values","text":"int a = (rand() % 2000) - 1000; // -1000 ~ 999","title":"Generate random number contains negative values"},{"location":"sorting/contains_duplicate/","text":"217. Contains Duplicate Source Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Constraints 1 <= nums.length <= 105 -109 <= nums[i] <= 109 Concept There're serveral method could be used to solve this problem - Sorting , map , set . Sorting If we find out a number is equal to its adjacent element, return true immediately. map Using number as key of map and the occurence as the value, if there's one occurence more than one, we'll return true. set Using set as container and copy all nodes to that. Comparing the size between these two containers, return true if they're different. Complexity Time Complexity Sorting: O(nlogn) Map: O(n) Set: (n) Space Complexity Sorting: O(logn), the space needed when sorting elements. Map: O(n), we'd use as many as the input number when they're all different. Set: (n), same as map. Code Sort bool containsDuplicate(vector<int>& nums) { sort(nums.begin(), nums.end()); int len = nums.size(); for (int i=1; i<len; i++) { if (nums[i-1] == nums[i]) return true; } return false; } Set bool containsDuplicate(vector<int>& nums) { set<int> st(nums.begin(), nums.end()); return nums.size() > st.size(); } Map bool containsDuplicate(vector<int>& nums) { map<int, int> mp; for (auto n : nums) { mp[n]++; } for (auto m : mp) if (m.second > 1) return true; return false; }","title":"217. Contains Duplicate"},{"location":"sorting/contains_duplicate/#217-contains-duplicate","text":"Source Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Constraints 1 <= nums.length <= 105 -109 <= nums[i] <= 109","title":"217. Contains Duplicate"},{"location":"sorting/contains_duplicate/#concept","text":"There're serveral method could be used to solve this problem - Sorting , map , set . Sorting If we find out a number is equal to its adjacent element, return true immediately. map Using number as key of map and the occurence as the value, if there's one occurence more than one, we'll return true. set Using set as container and copy all nodes to that. Comparing the size between these two containers, return true if they're different.","title":"Concept"},{"location":"sorting/contains_duplicate/#complexity","text":"Time Complexity Sorting: O(nlogn) Map: O(n) Set: (n) Space Complexity Sorting: O(logn), the space needed when sorting elements. Map: O(n), we'd use as many as the input number when they're all different. Set: (n), same as map.","title":"Complexity"},{"location":"sorting/contains_duplicate/#code","text":"Sort bool containsDuplicate(vector<int>& nums) { sort(nums.begin(), nums.end()); int len = nums.size(); for (int i=1; i<len; i++) { if (nums[i-1] == nums[i]) return true; } return false; } Set bool containsDuplicate(vector<int>& nums) { set<int> st(nums.begin(), nums.end()); return nums.size() > st.size(); } Map bool containsDuplicate(vector<int>& nums) { map<int, int> mp; for (auto n : nums) { mp[n]++; } for (auto m : mp) if (m.second > 1) return true; return false; }","title":"Code"},{"location":"sorting/largest_number/","text":"179. Largest Number Source Given a list of non-negative integers nums, arrange them such that they form the largest number and return it. Since the result may be very large, so you need to return a string instead of an integer. Constraints 1 <= nums.length <= 100 0 <= nums[i] <= 109 Concept We need to customize a sorting comparator in our way. Before to sort the array, we have to convert the data type from integer to string to prevent from overflow during sorting. Consider a case of [21474836, 7] , we would get an overflow exception while compose 7 + 21474836 because it's bigger than INT_MAX. The rule of comparator is s1+s2 > s2+s1 where s1 and s2 is the string in the array. After sorting is complete, we should check the resultant string by removing the leading zero because the edge case [0,0,0] could come out with 000 . Complexity Time Complexity O(nlogn): The sorting algorithm. Space Complexity O(n): Need an extra space to store the result. Special test case [0,0,0,0,0,0,0] [1,2,3,4,5,6,7,8,9,0] Code class Solution { public: string largestNumber(vector<int>& nums) { vector<string> strs; std::transform(nums.begin(), nums.end(), std::back_inserter(strs), [](int n) {return std::to_string(n); }); sort(strs.begin(), strs.end(), [](string &s1, string &s2){ return s1+s2>s2+s1; }); stringstream ss; for (auto s : strs) { ss << s; } string ans = ss.str(); while (ans[0]=='0' && ans.length()>1) ans.erase(0, 1); return ans; } };","title":"179. Largest Number"},{"location":"sorting/largest_number/#179-largest-number","text":"Source Given a list of non-negative integers nums, arrange them such that they form the largest number and return it. Since the result may be very large, so you need to return a string instead of an integer. Constraints 1 <= nums.length <= 100 0 <= nums[i] <= 109","title":"179. Largest Number"},{"location":"sorting/largest_number/#concept","text":"We need to customize a sorting comparator in our way. Before to sort the array, we have to convert the data type from integer to string to prevent from overflow during sorting. Consider a case of [21474836, 7] , we would get an overflow exception while compose 7 + 21474836 because it's bigger than INT_MAX. The rule of comparator is s1+s2 > s2+s1 where s1 and s2 is the string in the array. After sorting is complete, we should check the resultant string by removing the leading zero because the edge case [0,0,0] could come out with 000 .","title":"Concept"},{"location":"sorting/largest_number/#complexity","text":"Time Complexity O(nlogn): The sorting algorithm. Space Complexity O(n): Need an extra space to store the result.","title":"Complexity"},{"location":"sorting/largest_number/#special-test-case","text":"[0,0,0,0,0,0,0] [1,2,3,4,5,6,7,8,9,0]","title":"Special test case"},{"location":"sorting/largest_number/#code","text":"class Solution { public: string largestNumber(vector<int>& nums) { vector<string> strs; std::transform(nums.begin(), nums.end(), std::back_inserter(strs), [](int n) {return std::to_string(n); }); sort(strs.begin(), strs.end(), [](string &s1, string &s2){ return s1+s2>s2+s1; }); stringstream ss; for (auto s : strs) { ss << s; } string ans = ss.str(); while (ans[0]=='0' && ans.length()>1) ans.erase(0, 1); return ans; } };","title":"Code"},{"location":"sorting/merge_intervals/","text":"56. Merge Intervals Source Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Constraints 1 <= intervals.length <= 104 intervals[i].length == 2 0 <= starti <= endi <= 104 Concept If the source array has been sorted, then we could compare the second value of last item in the output list in one pass. So what is overlap in this problem? We could define the overlap as intervals[i-1][1] < intervals[i][0] . Since the intervals is sorted previously which means we could put the first item to output array and compare next item with output array one by one. Complexity Time Complexity O(nlogn): Assuming the sorting algorithm is O(nlogn). Then the following one pass check( linear scan ) has complexity O(n) Space Complexity O(logn): The sorting algorithm might need an extra space. Special test case [[1,4],[0,0]] [[2,3],[4,5],[6,7],[8,9],[1,10]] Code class Solution { public: vector<vector<int>> merge(vector<vector<int>>& intervals) { vector<vector<int>> merged; sort(intervals.begin(), intervals.end()); // Sort by the first element, so we can easily compare the second in one pass for (auto val : intervals) { if (merged.empty() || merged.back()[1] < val[0]) // Append to list if it's not overlapped. merged.push_back(val); else merged.back()[1] = max(merged.back()[1], val[1]); // If it's overlap, pick max from the two tails. } return merged; } };","title":"56. Merge Intervals"},{"location":"sorting/merge_intervals/#56-merge-intervals","text":"Source Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Constraints 1 <= intervals.length <= 104 intervals[i].length == 2 0 <= starti <= endi <= 104","title":"56. Merge Intervals"},{"location":"sorting/merge_intervals/#concept","text":"If the source array has been sorted, then we could compare the second value of last item in the output list in one pass. So what is overlap in this problem? We could define the overlap as intervals[i-1][1] < intervals[i][0] . Since the intervals is sorted previously which means we could put the first item to output array and compare next item with output array one by one.","title":"Concept"},{"location":"sorting/merge_intervals/#complexity","text":"Time Complexity O(nlogn): Assuming the sorting algorithm is O(nlogn). Then the following one pass check( linear scan ) has complexity O(n) Space Complexity O(logn): The sorting algorithm might need an extra space.","title":"Complexity"},{"location":"sorting/merge_intervals/#special-test-case","text":"[[1,4],[0,0]] [[2,3],[4,5],[6,7],[8,9],[1,10]]","title":"Special test case"},{"location":"sorting/merge_intervals/#code","text":"class Solution { public: vector<vector<int>> merge(vector<vector<int>>& intervals) { vector<vector<int>> merged; sort(intervals.begin(), intervals.end()); // Sort by the first element, so we can easily compare the second in one pass for (auto val : intervals) { if (merged.empty() || merged.back()[1] < val[0]) // Append to list if it's not overlapped. merged.push_back(val); else merged.back()[1] = max(merged.back()[1], val[1]); // If it's overlap, pick max from the two tails. } return merged; } };","title":"Code"},{"location":"string/letter_combinations_of_a_phone_number/","text":"17. Letter Combinations of a Phone Number Source Topic : Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Constraints 0 <= digits.length <= 4 digits[i] is a digit in the range ['2', '9']. Concept We need a vector to store the letter, and the output array will be initialized to \"\"( vector<string> out(1, \"\") ). The answer comes after the following steps: Iterate the input string digits For every digit which we are visiting, then enumerate letters regarding current digit. Combine the string separately with current letter. Using assign() or swap() to change the content of output buffer. Complexity Time Complexity O(4^n): n is the length of digits Space Complexity Special test case Code class Solution { public: vector<string> letterCombinations(string digits) { if (digits.empty()) return {}; vector<string> ss = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; vector<string> out(1, \"\"); // Key point, need to initialze as \"\" for (auto d : digits) { vector<string> vx; for (auto c : ss[d - '0']) { // Relative offset to '0' for (auto o : out) { // Because we've initialized to \"\", so there will \"\" + \"a\"... vx.push_back(o+c); } } // out.assign(vx.begin(), vx.end()); out.swap(vx); // This should be constant time. } return out; } };","title":"17. Letter Combinations of a Phone Number"},{"location":"string/letter_combinations_of_a_phone_number/#17-letter-combinations-of-a-phone-number","text":"Source Topic : Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Constraints 0 <= digits.length <= 4 digits[i] is a digit in the range ['2', '9'].","title":"17. Letter Combinations of a Phone Number"},{"location":"string/letter_combinations_of_a_phone_number/#concept","text":"We need a vector to store the letter, and the output array will be initialized to \"\"( vector<string> out(1, \"\") ). The answer comes after the following steps: Iterate the input string digits For every digit which we are visiting, then enumerate letters regarding current digit. Combine the string separately with current letter. Using assign() or swap() to change the content of output buffer.","title":"Concept"},{"location":"string/letter_combinations_of_a_phone_number/#complexity","text":"Time Complexity O(4^n): n is the length of digits Space Complexity","title":"Complexity"},{"location":"string/letter_combinations_of_a_phone_number/#special-test-case","text":"","title":"Special test case"},{"location":"string/letter_combinations_of_a_phone_number/#code","text":"class Solution { public: vector<string> letterCombinations(string digits) { if (digits.empty()) return {}; vector<string> ss = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; vector<string> out(1, \"\"); // Key point, need to initialze as \"\" for (auto d : digits) { vector<string> vx; for (auto c : ss[d - '0']) { // Relative offset to '0' for (auto o : out) { // Because we've initialized to \"\", so there will \"\" + \"a\"... vx.push_back(o+c); } } // out.assign(vx.begin(), vx.end()); out.swap(vx); // This should be constant time. } return out; } };","title":"Code"},{"location":"string/zigzag_conversion/","text":"6. Zigzag Conversion Source Topic : The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Constraints 1 <= s.length <= 1000 s consists of English letters (lower-case and upper-case), ',' and '.'. 1 <= numRows <= 1000 Concept Image we have multiple rows and then we put character one by one to each row, what we do is: Make sure we have enough rows to put character Change the direction if the index reach to the bound Complexity Time Complexity O(n): n == s.length() Space Complexity O(n): n is max(numRows, s.length()) Special test case We add max(numRows, s.length()) when initializing vector to make sure there will have sufficient space. \"AB\" 1 Code class Solution { public: string convert(string s, int numRows) { vector<string> vx(max(numRows, (int)s.length()), \"\"); int idx = 0; bool godown = true; for (char c : s) { vx[idx].push_back(c); idx += godown ? 1 : -1; if (idx==0 || idx==numRows-1) godown = !godown; } string ans; for (string str : vx) { ans += str; } return ans; } };","title":"6. Zigzag Conversion"},{"location":"string/zigzag_conversion/#6-zigzag-conversion","text":"Source Topic : The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Constraints 1 <= s.length <= 1000 s consists of English letters (lower-case and upper-case), ',' and '.'. 1 <= numRows <= 1000","title":"6. Zigzag Conversion"},{"location":"string/zigzag_conversion/#concept","text":"Image we have multiple rows and then we put character one by one to each row, what we do is: Make sure we have enough rows to put character Change the direction if the index reach to the bound","title":"Concept"},{"location":"string/zigzag_conversion/#complexity","text":"Time Complexity O(n): n == s.length() Space Complexity O(n): n is max(numRows, s.length())","title":"Complexity"},{"location":"string/zigzag_conversion/#special-test-case","text":"We add max(numRows, s.length()) when initializing vector to make sure there will have sufficient space. \"AB\" 1","title":"Special test case"},{"location":"string/zigzag_conversion/#code","text":"class Solution { public: string convert(string s, int numRows) { vector<string> vx(max(numRows, (int)s.length()), \"\"); int idx = 0; bool godown = true; for (char c : s) { vx[idx].push_back(c); idx += godown ? 1 : -1; if (idx==0 || idx==numRows-1) godown = !godown; } string ans; for (string str : vx) { ans += str; } return ans; } };","title":"Code"},{"location":"two_pointers/3Sum/","text":"15. 3Sum Source Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. Constraints 0 <= nums.length <= 3000 -105 <= nums[i] <= 105 Concept Two Pointers Before using two poiters strategy, we have to sort the input array first so that it can be easily to compare. The algorithm is: Sort the array Set the target=0-nums[i] because we will check the rest elements to find out if there's a pair which sum equal to target. The key point is to set left pointer l to the next of current digit and set right pointer r to the end of array. If nums[l]+nums[r] < target , we need to move l to the right by 1. If nums[l]+nums[r] > target , we need to move r to the left by 1. If nums[l]+nums[r] == target , it means there's a solution found. Then we iterate moving l or r pointers if its next elements is equal. Complexity Time Complexity O(n^2): The sorting takes O(nlogn), and the worst case of visiting elements will be O(n^2). So O(nlogn + n^2) will be O(n^2) Space Complexity Code class Solution { public: vector<vector<int>> threeSum(vector<int>& nums) { sort(nums.begin(), nums.end()); vector<vector<int>> vx; int len = nums.size(); for (int i=0; i<len-2; i++) { if (i>0 && nums[i]==nums[i-1]) continue; int l=i+1, r=len-1; int target = 0 - nums[i]; while (l<r) { if (nums[l]+nums[r] < target) l++; else if (nums[l]+nums[r] > target) r--; else { vx.push_back({nums[i], nums[l], nums[r]}); while (l<r && nums[l]==nums[l+1]) l++; while (l<r && nums[r]==nums[r-1]) r--; l++; r--; } } } return vx; } };","title":"15. 3Sum"},{"location":"two_pointers/3Sum/#15-3sum","text":"Source Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. Constraints 0 <= nums.length <= 3000 -105 <= nums[i] <= 105","title":"15. 3Sum"},{"location":"two_pointers/3Sum/#concept","text":"Two Pointers Before using two poiters strategy, we have to sort the input array first so that it can be easily to compare. The algorithm is: Sort the array Set the target=0-nums[i] because we will check the rest elements to find out if there's a pair which sum equal to target. The key point is to set left pointer l to the next of current digit and set right pointer r to the end of array. If nums[l]+nums[r] < target , we need to move l to the right by 1. If nums[l]+nums[r] > target , we need to move r to the left by 1. If nums[l]+nums[r] == target , it means there's a solution found. Then we iterate moving l or r pointers if its next elements is equal.","title":"Concept"},{"location":"two_pointers/3Sum/#complexity","text":"Time Complexity O(n^2): The sorting takes O(nlogn), and the worst case of visiting elements will be O(n^2). So O(nlogn + n^2) will be O(n^2) Space Complexity","title":"Complexity"},{"location":"two_pointers/3Sum/#code","text":"class Solution { public: vector<vector<int>> threeSum(vector<int>& nums) { sort(nums.begin(), nums.end()); vector<vector<int>> vx; int len = nums.size(); for (int i=0; i<len-2; i++) { if (i>0 && nums[i]==nums[i-1]) continue; int l=i+1, r=len-1; int target = 0 - nums[i]; while (l<r) { if (nums[l]+nums[r] < target) l++; else if (nums[l]+nums[r] > target) r--; else { vx.push_back({nums[i], nums[l], nums[r]}); while (l<r && nums[l]==nums[l+1]) l++; while (l<r && nums[r]==nums[r-1]) r--; l++; r--; } } } return vx; } };","title":"Code"},{"location":"two_pointers/3Sum_closest/","text":"16. 3Sum Closest Source Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Constraints 3 <= nums.length <= 1000 -1000 <= nums[i] <= 1000 -104 <= target <= 104 Concept This problem is similar to 3 Sum , so we could solve it with Two Pointers strategy, the algorithm will be: Sort the input array so that we will adjust the sum by moving left/right pointers. Initialize variable cloeset as the sum of first 3 values because we know there will be at least 3 elements in the array. Note that we can't set cloeset = INT_MAX because it'd raise overflow exception when the target is negative during the statement abs(closest-target) . Then we iterately compare the sum with target by moving left/right pointers. Re-assign closest to sum when we got a smaller answer exist. Complexity Time Complexity O(nlogn + nlogn) = O(nlogn): Where the outer loop has complexity O(n) and inner loop has complexity (logn). The sorting has complexity O(nlogn) Space Complexity O(1): Constant memory. Code class Solution { public: int threeSumClosest(vector<int>& nums, int target) { sort(nums.begin(), nums.end()); int closest = nums[0] + nums[1] + nums[2]; // nums.size() >= 3 && cannot be INT_MAX since abs(closest-target) may cause overflow with case [1,1,1,1] -100 int len = nums.size(); for (int i=0; i<len-2; i++) { int l = i+1, r=len-1; while (l<r) { int sum = nums[i]+nums[l]+nums[r]; if (sum > target) r--; else l++; if (abs(sum-target) < abs(closest-target)) closest = sum; } } return closest; } };","title":"16. 3Sum Closest"},{"location":"two_pointers/3Sum_closest/#16-3sum-closest","text":"Source Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Constraints 3 <= nums.length <= 1000 -1000 <= nums[i] <= 1000 -104 <= target <= 104","title":"16. 3Sum Closest"},{"location":"two_pointers/3Sum_closest/#concept","text":"This problem is similar to 3 Sum , so we could solve it with Two Pointers strategy, the algorithm will be: Sort the input array so that we will adjust the sum by moving left/right pointers. Initialize variable cloeset as the sum of first 3 values because we know there will be at least 3 elements in the array. Note that we can't set cloeset = INT_MAX because it'd raise overflow exception when the target is negative during the statement abs(closest-target) . Then we iterately compare the sum with target by moving left/right pointers. Re-assign closest to sum when we got a smaller answer exist.","title":"Concept"},{"location":"two_pointers/3Sum_closest/#complexity","text":"Time Complexity O(nlogn + nlogn) = O(nlogn): Where the outer loop has complexity O(n) and inner loop has complexity (logn). The sorting has complexity O(nlogn) Space Complexity O(1): Constant memory.","title":"Complexity"},{"location":"two_pointers/3Sum_closest/#code","text":"class Solution { public: int threeSumClosest(vector<int>& nums, int target) { sort(nums.begin(), nums.end()); int closest = nums[0] + nums[1] + nums[2]; // nums.size() >= 3 && cannot be INT_MAX since abs(closest-target) may cause overflow with case [1,1,1,1] -100 int len = nums.size(); for (int i=0; i<len-2; i++) { int l = i+1, r=len-1; while (l<r) { int sum = nums[i]+nums[l]+nums[r]; if (sum > target) r--; else l++; if (abs(sum-target) < abs(closest-target)) closest = sum; } } return closest; } };","title":"Code"}]}